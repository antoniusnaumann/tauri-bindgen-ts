use proc_macro::TokenStream;
use quote::{quote, format_ident};
use syn::{ItemFn, FnArg, Type, Pat, PatType, Path, Ident};

use ts_rs::TS;

#[proc_macro_attribute]
pub fn entity(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let item: proc_macro2::TokenStream = item.into();

    quote! {
        #[derive(TS)]
        #[ts(export)]
        #[ts(export_to="../src-gen/")]
        #item
    }.into()
}

#[proc_macro_attribute]
pub fn command(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let func = syn::parse::<ItemFn>(item.clone()).expect("Could not parse function");
    let item: proc_macro2::TokenStream = item.into();
    let ts_func = func_to_ts(func);
    let test = generate_test(ts_func);

    quote! {
        #[tauri::command]
        #item
        #test
    }.into()
}

struct TsFunc {
    name: String,
    binding: String,
    args: Vec<(Ident, Path)>,
}

fn func_to_ts(func: ItemFn) -> TsFunc {
    let name = func.sig.ident.to_string();
    // TODO: Implement mechanism to skip args such as tauris app handle (can be done with attrs
    let args = func.sig.inputs.into_iter()
        .filter_map(|arg| if let FnArg::Typed(t) = arg { Some(t) } else { panic!("Only top-level functions are allowed as commands!") })
        .collect::<Vec<_>>();
    // TODO: Support more function arg types
    let args = types(&args);

    // TODO: Convert name to snake case
    let binding = format!("export async function {name}(%0) {{ return await invoke('{name}', {{ %1 }}) }}");

    TsFunc { name, binding, args }
}

fn types(args: &[PatType]) -> Vec<(Ident, Path)> {
    args.iter()
        .map(|arg| (arg.pat.clone(), arg.ty.clone()))
        .filter_map(|(pat, ty)| if let Pat::Ident(p) = *pat { Some((p, ty)) } else { panic!("Only simple owned types are allowed as arguments at the moment!") })
        .filter_map(|(pat, ty)| if let Type::Path(t) = *ty { Some((pat, t)) } else { panic!("Only simple owned types are allowed as arguments at the moment!") })
        .map(|(pat, ty)| (pat.ident, ty.path))
        .collect()
}

fn generate_test(func: TsFunc) -> proc_macro2::TokenStream {
    let TsFunc { name, binding, args } = func;
    let arg_names = args.iter().map(|(ident, _)| ident.to_string()).collect::<Vec<_>>();
    let arg_types = args.iter().map(|(_, path)| path).collect::<Vec<_>>();

    let test_fn = format_ident!("export_function_bindings_{}", name);

    let dir = "../src-gen";
    let header = "// This file is autogenerated by tauri-bindgen-ts and should not be modified manually";
    let import = "import { invoke } from \"@tauri-apps/api/tauri\"";

    let file_name = format!("{dir}/{name}.ts");
    let content = format!("{header}\n{import}\n\n{binding}");

    quote! {
        #[cfg(test)]
        #[test]
        fn #test_fn() {
            use std::fs;
            use ts_rs::TS;

            let types = vec![#(#arg_types::name()),*];
            let names = vec![#(#arg_names),*];
            let args = types.iter().enumerate().map(|(index, elem)| [names[index].to_owned(), elem.to_owned()].join(": ")).collect::<Vec<String>>().join(", ");

            fs::create_dir_all(#dir).expect("Could not create directory");
            fs::write(#file_name, #content.replace("%0", args.as_str()).replace("%1", names.join(", ").as_str())).expect("Could not write generated function binding to file");
        }
    }
}