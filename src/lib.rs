use proc_macro::TokenStream;
use quote::{quote, format_ident};
use syn::{ItemFn, FnArg, Type};

#[proc_macro_attribute]
pub fn entity(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let item: proc_macro2::TokenStream = item.into();

    quote! {
        #[derive(TS)]
        #[ts(export)]
        #[ts(export_to="../src-gen/")]
        #item
    }.into()
}

#[proc_macro_attribute]
pub fn command(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let func = syn::parse::<ItemFn>(item.clone()).expect("Could not parse function");
    let item: proc_macro2::TokenStream = item.into();
    let ts_func = func_to_ts(func);
    let test = generate_test(ts_func);

    quote! {
        #[tauri::command]
        #item
        #test
    }.into()
}

struct TsFunc {
    name: String,
    binding: String,
}

fn func_to_ts(func: ItemFn) -> TsFunc {
    let name = func.sig.ident.to_string();
    // TODO: Implement mechanism to skip args such as tauris app handle (can be done with attrs)
    let args = func.sig.inputs.iter().filter_map(|arg| if let FnArg::Typed(t) = arg { Some(t) } else { None });
    // TODO: Support more function arg types
    let ts_args = args.map(|arg| arg.ty.clone()).filter_map(|ty| if let Type::Verbatim(t) = *ty { Some(t) } else { None }).collect::<Vec<_>>();

    // TODO: Convert name to snake case
    let binding = format!("export async function {name}(/*TODO: Insert parameters*/) {{ return await invoke('{name}' /*TODO: Insert parameters*/) }}");

    TsFunc { name, binding }
}

fn generate_test(func: TsFunc) -> proc_macro2::TokenStream {
    let TsFunc { name, binding } = func;
    let test_fn = format_ident!("export_function_bindings_{}", name);

    let dir = "../src-gen";
    let header = "// This file is autogenerated by tauri-bindgen-ts and should not be modified manually";
    let import = "import { invoke } from \"@tauri-apps/api/tauri\"";

    let file_name = format!("{dir}/{name}.ts");
    let content = format!("{header}\n{import}\n\n{binding}");

    quote! {
        #[cfg(test)]
        #[test]
        fn #test_fn() {
            use std::fs;

            fs::create_dir_all(#dir).expect("Could not create directory");
            fs::write(#file_name, #content).expect("Could not write generated function binding to file");
        }
    }
}